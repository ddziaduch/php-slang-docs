{"pages":[{"title":"PhpSlang","text":"PhpSlang - Functional PHP the right way Library code and this documentation are distributed under MIT License. Installation &amp; requirements PhpSlang is super easy to install and it has no externall dependencies except a PHP7+ Install with composer: composer install php-slang\/php-slang That's all! You are ready to go! Now it's highly recomended to read a whole documentation. This documentation was created not only to describe a PhpSlang library, but also to give you a good, smooth introduction to purely functional programming in general.","tags":"","url":"index.html"},{"title":"Thinking Functional","text":"Why? Functional programming became a buzzword of all software conferences in few last years. PHP community does it's best to keep pace because there is a lot to gain. What are the biggest benefits of functional programming? Less bugs Maintainable code Scalability out of box Easier testing Shorter code Easy to learn You gain all of this by switching to FP (and PhpSlang will help you with it). Take all of these advantages for granted at the moment - we will cover points above in a while. Short intro Some people say that when you want to learn program functionally you have to forget everything you know about programming and go back to school and your math teacher should be your programming master from this day. There's a lot of truth in such thinking, but not completely - eg. OOP and FP create a great couple so all you know about inheritance, composition etc. is still on the menu. Staring to code purely functional does not discard all good practices like DRY, SOLID, YAGNI neither. Even more - if you're familiar with Domain Driven Design - you'll see that functional thinking can be applied not only to specific pieces of code, but to the architectural decisions as well. See this great Greg Young's talk for a reference (if you ask yourself what event sourcing has to do with DDD check out Eric Evans book). The problem (with imperative programming) Every day headache Does this story feel familiar to you? Or bunch of other funny pictures about developers struggling with NullPointerExceptions or OutOfBoundExceptions? There are tons of everyday small glitches in our projects. Sometimes such problems are resolved at code review when other developers in your team find it, sometimes on production instance when angry clients start to call a support line. We have to keep in mind lots of tiny dependencies that sum up to huge graph of connections which most developers have to keep in mind when maintaining existing code. The problem is that we are just humans and our buffer is quite tiny and easy to flush. Scalability issues How many simultaneous threads with concurrent access to your data you're able to implement with full confidence? 2? 10? 20? What would you say about 100000? It is possible with pure functions. With shared mutable state not. And scalability is just one dimension of a whole problem. Mutability is counterintuitive The business requirements tend to grow and change. FP won't solve all your problems with complexity but will not create separate complexity on it's own and using immutable data structures and monads will help you handle this complexity. Imperative style can seem like a standard way of giving your computer instructions to process. That's how computers work - instruction after instruction, are'nt they? Well maybe (as long we're using Von Neumann computers) but it's definitely not how human brains work and not how the world around us works. Do you remember when the last time some physical object in your surrounding was just reasigned? The solution 1. Immutability! The biggest difference between eg. Haskell and PHP is that you CAN NOT reassign values. Keeping immutability will require a lot more discipline on your side when you use PHP, but syntax in not important - thinking is! From this day just keep in mind that: There is no such thing as variable! Forget about changing state of variables in random places. All your code should be build of small logical blocks which are: Easy to reason about Every function should return the same result when run with the same set of input data. This way you don't have to think about tons of dependencies inside your code. When you want to do something - you just run a function and you can be sure that it will behave in the same way every time. 2. Ask a right questions Imperative paradigm which is a standard for most of PHP applications leaves you with a code that describes HOW TO achieve things. Functional paradigm leaves you with a code that describes WHAT you want to achieve. 3. Function as a first class citizen It must be mentioned because - well it's a functional programming. Points below are rather a technical detail - but when you have these tools, completely new possibilities are open for you. Currying - functions can return another functions as well. Higher order functions - functions can be passed as arguments to other functions. Anonymous functions - you can define a function just in a place you use them. Functions can be assigned to a variable (and object scope as well). Pros Less bugs Immutability - again. Lets consider a following linear function you can remember from your childhood: f(x) = x * 2 When x equals 2 you just know that the result of computation is 4. When 6 it's 12, when 7 it's 14 and so on. More important than what this function does is what this function DOES NOT. This function DOES NOT: set any kind of variables which are reused in next executions add new objects to globally available array create a temporary array to accumulate computed data This is just a simple example, but it's actually an ultimate point of FP. Maintainable code Code describes WHAT it does, not HOW. So you don't have to think that much on what was the intention of a developer who created this piece of code - this information is already here. Having a project written in a purely functional manner means also easier debugging and code navigation. As long as all function calls are explicit, you'll see very little or no surprises when debugging. Scalability out of box The biggest challenge of distributed architecture is concurrent access to data. You never know if a state is up to date and who uses specific entities at the moment. Concurrency creates tons of problems which can be solved using ideas like locks, mutexes, semaphores etc. but it requires a lot of effort and creates new problems you have to keep in mind when extending existing solutions. With immutable code and immutable data structures you can forget about all this stuff. When result of a function is the same every time, there is no risk of running it in parallel on few CPU cores or even few physical machines. You don't share a memory so code is not only more predictable but simply works faster. Check Future and Parallel Collections for more information on this topic. Easier testing No initialization. No tests for various states of dependent variables. No side effects checks. Much less mocking and stubbing. Just simple checks for return value and domain specific edge cases. And again: TDD and BDD are still on the menu. Shorter code When you use nested function calls you end up with a much more condensed code. Pipelined calls also tend to take less space and when everything is immutable, most of your functions contain only one return statement - which appears in a first line of a method (yes braces, semicolon and return keyword become to seem redundant - but unfortunately you still have to use them in PHP). Code condensation is visible especially for immutable collections - when you chain eg. map() and filter() calls it becomes readable even for people with no developing skills. Easy to learn One of the biggest myths of functional programming is that it has a big entry level. Source of such a belief can be found in a track of life of an experienced software developers. They are used to see small increments. When you develop with Zend for 3 years and then jump to Symfony - most of concepts are the same, only approach to solve problems is different. Functional programming requires you to really change the way you think (and it can be painful at the beginning), but it's really not that much to learn (there's actually less things you have to learn to start compared to OOP). When currying and monads give you a headache remember days when questions like 'what is a difference between interface and abstract class' were hard to answer for you - you have to fill the gaps in your knowledge but from a perspective it's actually not that hard. OK, but my app has to store user input. It can seem like a not so easy question to answer keeping in mind that all materials about FP repetitively convince you not mutate data at all, but it does'nt mean that FP is limited only to transform data without side effects. For an average PHP developer the simple answer is - store all your state changes in a database. That is the only place where data changes should happen. Immutability also does'nt mean that you cant create eg. database engine with purely functional language - check Haskel's STM for a reference. There's also a high chance that you are familiar with RabbitMQ which is written in Erlang. There is a lot of other software written in purely functional languages which are capable of storing varying data, only approach to data changes is different. Show me the code It's a prolixity without showing the code, so let's see this small example. Both functions below return the same result for identical input. The only difference is used paradigm. Imperative implementation: function averageOfNumbersSmallerThan(array $numbers, int $threshold) : string { $numbersSmallerThanThreshold = []; foreach ($numbers as $number) { if ($number &lt;= $threshold) { $numbersSmallerThanThreshold[] = $number; } } $numbersDividedByThree = []; foreach ($numbersSmallerThanThreshold as $number) { $numbersDividedByThree = $number \/ 3; } $average = null; if (count($numbersDividedByThree) &gt; 0) { foreach ($numbersDividedByThree as $number) { if (is_null($average) { $average = $number; } else { $average = ($average + $number) \/ 2; } } } if (is_null($average) { return 'It\\'s impossible to count average for a given data.'; } else { return 'Average is: ' . $average; } } ?&gt; Functional implementation (using PhpSlang): function averageOfNumbersSmallerThan(ListCollection $numbers, int $threshold) : string { return $numbers -&gt;filter(function($number) use ($threshold) { return $number &lt;= $threshold; }) -&gt;map(function($number) { return $number \/ 3; }) -&gt;avg() -&gt;map(function($avg) { return 'Average is: ' . $avg; }) -&gt;getOrElse('It\\'s impossible to count average for a given data.'); } ?&gt; Summing things up Does an example above look convincing? It's just a beginning. Remember that this example describes only one method and we're just scrapping the surface here. We did'nt even touched the danger zones of exception handling, mutable object fields, validation and any kind of storage. The most important facts to remember before reading other materials on functional programming are: immutability - lets you deal with complexity and helps you create code which won't surprise you WHAT not HOW - this is the question that should be answered by your code treat function as a first class citizen - your system is composed of functions - they deserve some respect. Have fun with functional programming!","tags":"","url":"Introduction\/Thinking_Functional.html"},{"title":"Fast Introduction To FP In PHP","text":"What this article is about and what is'nt? This part of PhpSlang documentation covers basic syntax constructs given by PHP that are crutial in terms of functional proogramming. This article also display what is possible in PHP with functionall approach and what is'nt. This is not a tutorial on how to program functionally and\/or with a PhpSlang library. Minimal survival resources Functional programming is a style. It works in any programming language. Brian Beckman This is a great quote, especially in case of PHP which usually isn't a first thought when you talk about FP. Well this quote isn't true for every programming language. If you want to program functionally you need one crucial feature in a language: Function is a fisrt class citizen. What does it mean? can be stored in variables and data structures can be passed as a parameter to a subroutine can be returned as the result of a subroutine can be constructed at runtime has intrinsic identity (independent of any given name) In other words: you can assign function to &quot;variable&quot;, return customized function from another function and take as an argument using standard language constructs with no need to rely on reflection. Does PHP fulfill all listed requirements? - YES... well almost. To have a better picture, take a look at this table at Wikipedia We see that two bits of a puzzle are missing. We'll go back to it later in this article. Function definition Just to remind. The simplest example as it only can be: public foo($a) { return $a * 2; } This function returns parameter $a multiplied by 2. PHP gives us ability to typehint parameters taken by method and it's result so in this case it's safer (and recommended) to explicitly describe types: public foo(int $a): int { return $a * 2; } In PHP functions can be defined as part of classes - in that case we call them methods: class Bar { public function foo(int $a): int { return $a * 2; } } Things above are nobrainers. Every PHP developer arount the world uses those contructs everyday. But now it get's interesting. Function as a parameter Let's consider a following function (regartheless if it's just a dangling function or class method). function doSomethingFunnyWith(string $originalTxt, int $times, Closure $transformation): string { $accumulator = ''; for($i=0; $i &lt; $times ;$i++) { $accumulator .= $transformation($originalTxt); } return $accumulator; } This function: has no side effects contains variable $accumulator which is a bad practice in perspective of FP (and also when you thing about scalability), but we'll cover this topic later take 3 parameters: - some string to play with - numeric value to indicate how many times we want to repeat transofmed text - Closure (method) which is then used to transform $originalTxt When function takes another function as an argument we call it a higher-order function. Look closer at this part: $transformation($originalTxt) Function parameter named: $transformation is a function so we use it as a function, simply adding brackets and passing inside them function parameter(s) as we would do for every other function. How to use such function? String and int parameters don't require explanation but Closure needs some more attention because we rules and possibilities vary between different ways you use such function. Using higher order functions PHP gives you a way to define function just in a place you want to use it. Such functions are called anonymous functions. You don't give a name to such function, there is no way to reuse it in other parts of a code but it's also a very comfortable and popular way to define functions (and with FP approach you're going to write a lot of them). So if you'd like to print on screen &quot;D_O_OD_O_OD_O_O&quot; you could execute doSomethingFunnyWith in a following way: echo doSomethingFunnyWith( &quot;DOO&quot;, 3, function(string $inp): string { return implode('_', str_split($inp)); } ); But now let's consider a situation when you actually would like to define this function once and have an ability to reuse it. function underscoresEverywhere(string $inp): string { return implode('_', str_split($inp)); } and now let's use it: echo doSomethingFunnyWith( &quot;DOO&quot;, 3, underscoresEverywhere ); hmm... PHP Notice: Use of undefined constant underscoresEverywhere - assumed 'underscoresEverywhere' in ... on line ... Well maybe: echo doSomethingFunnyWith( &quot;DOO&quot;, 3, underscoresEverywhere() ); aahhh, again error: PHP Fatal error: Uncaught TypeError: Argument 1 passed to underscoresEverywhere() must be of the type string, none given, called in ... Quite frustrating huh? Well PHP isn't a perfect language for FP. When you want to: name a function AND be able to pass it as a parameter you have to assign it to a &quot;variable&quot; (the word variable is written with quotes because in FP you should rather think in terms of immutable values rather than variables). Do you remember wikipedia listing? Well - this is the reason why section Nested functions -&gt; Named is marked as yellow -&gt; Using anonymous. So what is a propper way to use such function? Version 1a As said previously - assign function to &quot;variable&quot;: $underscoresEverywhere = function (string $inp): string { return implode('_', str_split($inp)); };\/\/don't forget about semicolon :) echo doSomethingFunnyWith( &quot;DOO&quot;, 3, $underscoresEverywhere ); Version 1b Same approach but inside a class: class Foo { \/** * @var Closure *\/ $underscoresEverywhere; public function __construct() { $this-&gt;underscoresEverywhere = function (string $inp): string { return implode('_', str_split($inp)); }; \/\/BAD NEWS - passing methods inside class sucks too. If you want to make method &quot;passable&quot;, you \/\/ have to assign it to class field. } private function doSomethingFunnyWith(string $originalTxt, int $times, Closure $transformation): string { $accumulator = ''; for($i=0; $i &lt; $times ;$i++) { $accumulator .= $transformation($originalTxt); } return $accumulator; } public function testRide(): string { return $this-&gt;doSomethingFunnyWith( &quot;DOO&quot;, 3, $this-&gt;underscoresEverywhere ); } } echo (new Foo())-&gt;testRide(); \/\/remember about additional brackets around constructor usage, so you can chain method calls with no need to use variables Version 2a You can also wrap every named function\/method with the anonymous function: function underscoresEverywhere(string $inp): string { return implode('_', str_split($inp)); } echo doSomethingFunnyWith( &quot;DOO&quot;, 3, function(string $inp): string { return underscoresEverywhere($inp); } ); Version 2b Same as version 2a but for a class definition: class Foo { private function underscoresEverywhere(string $inp): string { return implode('_', str_split($inp)); } private function doSomethingFunnyWith(string $originalTxt, int $times, Closure $transformation): string { $accumulator = ''; for($i=0; $i &lt; $times ;$i++) { $accumulator .= $transformation($originalTxt); } return $accumulator; } public function testRide(): string { return $this-&gt;doSomethingFunnyWith( &quot;DOO&quot;, 3, function(string $inp): string { return $this-&gt;underscoresEverywhere($inp); } ); } } echo (new Foo())-&gt;testRide(); It may seem like this notation is quite verbosive, but it's actually a most popular and comfortable way use higher order functions in PHP. Well - PHP syntax does not spoil. \\Closure vs \\Callable One more way to implement the example we iterate with, is to use Callable type for doSomethingFunnyWith definition instead of Closure. class Foo { private function underscoresEverywhere(string $inp): string { return implode('_', str_split($inp)); } private function doSomethingFunnyWith(string $originalTxt, int $times, Callable $transformation): string { $accumulator = ''; for($i=0; $i &lt; $times ;$i++) { $accumulator .= $transformation($originalTxt); } return $accumulator; } public function testRide(): string { return $this-&gt;doSomethingFunnyWith( &quot;DOO&quot;, 3, [$this, 'underscoresEverywhere'] \/\/now you can pass a method name with a string ); } } echo (new Foo())-&gt;testRide(); Callable may seem like a default choice but it's actually more bug prone variant. Callable gives you some more flexibility, but with great power comes a great responsibility. Let's consider a following code example. class Foo { private youDontWantToRunThisMethod(): void { launchNuclearMissiles(); dropDatabase(); } private function underscoresEverywhere(string $inp): string { return implode('_', str_split($inp)); } private function doSomethingFunnyWith(string $originalTxt, int $times, Callable $transformation): string { $accumulator = ''; for($i=0; $i &lt; $times ;$i++) { $accumulator .= $transformation($originalTxt); } return $accumulator; } public function testRide(string $methodName): string { return $this-&gt;doSomethingFunnyWith( &quot;DOO&quot;, 3, [$this, $methodName] ); } } $userInput = 'underscoresEverywhere'; echo (new Foo())-&gt;testRide($userInput); $userInput = 'youDontWantToRunThisMethod'; echo (new Foo())-&gt;testRide($userInput); :) As you see - using strings to indicate which methods you want to use is a bad idea. Your IDE will have problems with proper types resolving, so you won't have code completions, so your live standard will drop and then everybody dies. Same rules apply to call_user_func method usage - you should avoid it at all costs as long as it's possible. For more info about differences between Closure and Callable please reffer to PHP official documentation \\Callable &amp; \\Closure Function as a result One more part that needs our attention is returning new functions from functions. Such mechanism is called currying. Let's rewrite again our method presenting &quot;D_O_OD_O_OD_O_O&quot; string. Let's say you'd like to customize letter used between characters, but the rest of a method should stay the same. Obvious and easiest method would be to just add another string parameter, but let's try another way. class Foo { \/\/that is a place where method underscoresEverywhere was located private function curriedStringFiller(string $glueWith): Closure { return function(string $inp) use ($glueWith): string { return implode($glueWith, str_split($inp)); }; } private function doSomethingFunnyWith(string $originalTxt, int $times, Closure $transformation): string { $accumulator = ''; for($i=0; $i &lt; $times ;$i++) { $accumulator .= $transformation($originalTxt); } return $accumulator; } public function testRide(): string { return $this-&gt;doSomethingFunnyWith( &quot;DOO&quot;, 3, $this-&gt;curriedStringFiller('+') ); } } echo (new Foo())-&gt;testRide(); This time you are going to end up with: &quot;D+O+OD+O+OD+O+O&quot; What happens in this example? Method curriedStringFiller returns another methos - it's anonymous function created at runtime. You can see one more PHP syntax keyword used which is use. You have to use such syntax to be able to use &quot;variables&quot; from outside scope inside your new anonymous methods (without use ($glueWith) you couldn't see content of this &quot;variable&quot;). Let's also look closer at lines: return $this-&gt;doSomethingFunnyWith( &quot;DOO&quot;, 3, $this-&gt;curriedStringFiller('+') ); Remember that $this-&gt;curriedStringFiller('+') actually does nothing with a string passed to doSomethingFunnyWith. It only returns a new function which is passed to doSomethingFunnyWith and then method doSomethingFunnyWith in it's internal implementation uses a resulting method to transform a string given as a first parameter. What we did in presented example could be written in a much shorter way if we used languages like JavaScript, Scala or Haskell. Those languages have build in mechanisms for currying and\/or partially applied functions* (every function can be used as curried - when you don't provide all required parameters to function, a new one is created and this new function requires only missing parameters from original one). Again - refer to Wikipedia listing for more info. This is a part where PHP lacks some basic functionality. There is just no such thing as Partial application in PHP. You may like to see what you loose that exists for Haskell, JavaScript 1, 2 or Scala 1, 2. But there is also a good news! You can live without this feature. When you'd use a partially applied function, you can create a new function instead (as presented in the example above, where we &quot;manually&quot; created a new function). One more last step Aa it was mentioned in introduction - this article covers PHP syntax elements required to be able to develop in a functional style, but may not display good practicies. Functional programming crutial principle is immutability. At the same time you could see that in code example we use for statement with variables like $i and $accumulator. Let's add some final touches to the last version of our class to make it purely functional. private function doSomethingFunnyWith(string $originalTxt, int $times, Closure $transformation): string { return array_reduce(range(1, $times), function(string $accumulator, int $item) use ($transformation, $originalTxt): string { return $accumulator.$transformation($originalTxt); }, ''); } What happened to doSomethingFunnyWith method? We used range method to generate list of $times elements, and then we used array_reduce method to iterate over range and build a final string (ignoring an $item variable, because we don't actually need it). With PhpSlang a final form of this class may look like this: use PhpSlang\\Collection\\ListCollection; class Foo { private function curriedStringFiller(string $glueWith): Closure { return function(string $inp) use ($glueWith): string { return implode($glueWith, str_split($inp)); }; } private function doSomethingFunnyWith(string $originalTxt, int $times, Closure $transformation): string { \/\/voil\u00c3\u00a0 - functional, referentially transparent, readable, chainable, very little or no error risk return (new ListCollection(range(1, $times))) -&gt;fold('', function(string $accumulator, int $item) use ($transformation, $originalTxt): string { return $accumulator.$transformation($originalTxt); }); } public function testRide(): string { return $this-&gt;doSomethingFunnyWith( &quot;DOO&quot;, 3, $this-&gt;curriedStringFiller('+') ); } } echo (new Foo())-&gt;testRide();","tags":"","url":"Introduction\/Fast_Introduction_To_FP_In_PHP.html"},{"title":"Dont be afraid of monads","text":"","tags":"","url":"Introduction\/Dont_be_afraid_of_monads.html"},{"title":"FAQ","text":"I read a documentation and did'nt found an answer. PhpSlang treads unclear documentation as a bug. If you have any issues with understanding described concepts or something is missing or misleading - feel free to create an issue on Github Where to start with functional programming? Honestly - not with PHP. Give a chance to Scala, Haskell, or Elixir. All great ideas you'll learn out there will change the way you use PHP, but it requires a lot of discipline to write immutable, purely functional code in PHP (and PhpSlang helps you here). PhpSlang documentation aims to become the most comprehensive guide on functional programming in PHP. There is not much resources of FP for PHP but concepts from other languages can be used with PHP as well. For more information's please refer to Other resources page. When not to use functional programming? Your default approach should be - write everything functionally. I promise, when you learn to write purely functional code there is no coming back. You'll want to write everything this way and when you'll face a problem which requires different approach you'll see this. There is no specific business domain where FP or traditional OOP is better. But keep in ming that a gold hammer does'nt exist. There are two fields of a reality where there is a common belief that FP performs worse: Embedded devices - when you write code for AVR or PIC microcontrollers and every bit of a memory matters - then it's probably best to stick with a classical C development. Sorting algorithms - there's a whole story behind a quick sort implementations for a variety of functional languages and benchmarks show that because of a mutational nature of quick sort it performs worse when implementation in a purely functional way. How about things you can't implement with functional approach? If you found such problem please let us know on Gitter chat. We'll be more that happy to help you solve the problem. If you have such issue it can indicate some bugs or shortages of PhpSlang. Why some parts of PhpSlang are not purely functional? It can seem like a lack of consequence, but keep in mind a main goal of a whole project. It was created to give PHP developers tools that will enable them to benefit from functional approach in a convenient way. It hides some ugly parts of PHP. Those ugly parts are still there, but with PhpSlang you don't have to deal with them every time you want to do something. How about mixing PhpSlang with other libraries? PhpSlang does'nt change a behaviour of PHP nor adds any kind of special keywords. It just provides helpful classes and functions. It's still PHP so you can mix approaches. If you want to have consistent code style - it's good to wrap\/extend existing libraries with PhpSlang constructs eg. Option::of() for all calls returning nullable results. I use library X and it returns different results when used along with PhpSlang. There is a high chance that one of two things happened: results of computations were wrong previously, but now with FP you fixed some bugs by an accident (such magical things happen when you force yourself to formalize every aspect of an application) results of computations were correct previously, but now are wrong - it probably indicated non-thread-safe code. Some libraries highly depend on mutations (even worse on mutations of static fields or globally accessible variables). This way in a middle of computations in method A, you change a state needed by method B. Please check if switching from ParallelListCollection (or other parallel collection) to ListCollection won't solve your problem. TL;DR look for race condition. I found a bug. Place an issue on Github so we know it exists. It will be fixed ASAP. I want to use it in a commercial project Feel free - it's distributed under MIT License. When feature X will be available? See Roadmap for a reference.","tags":"","url":"Introduction\/FAQ.html"},{"title":"Copy Trait","text":"The problem Take a look at this class. class House { \/** * @var string *\/ private $size; public function __construct(string $size) { $this-&gt;size = $size; } public function getSize() : string { return $this-&gt;size; } public function setSize(string $newSize) : House { $this-&gt;size = $newSize; return $this; } } It does not look suspicious as long as you don't use it. $smallHouse = new House('small'); $bigHouse = $smallHouse-&gt;setSize('big'); echo $bigHouse-&gt;getSize(); \/\/writes 'big' echo $smallHouse-&gt;getSize(); \/\/writes 'big' as well :( Why it works like that? Setters are not referentially transparent. Those methods mutate a state of an application and you, as a developer, have to remember about existence of such actions taken internally by methods you call. The naive solution class House { \/** * @var string *\/ public $size; public function __construct(string $size) { $this-&gt;size = $size; } public function getSize() : string { return $this-&gt;size; } public function withSize(string $newSize) : House { $clone = clone $this; $clone-&gt;size = $newSize; \/\/note that $size field had to be changed to public return $clone; } } Using a methods named with* instead of set* is a step forwards, but this solution still has some disadvantages. 1st - you have to write those 3 lines every time you want to get an object with value changed. 2nd - you have to make changed field public because when you clone $this and try to modify some field you don't have an access to private and protected fields anymore. Leaving those fields with such liberal property visibility may lead to a lot of troubles. The solution - Copy trait use PhpSlang\\Util\\Copy; class House { use Copy; \/** * @var string *\/ private $size; public function __construct(string $size) { $this-&gt;size = $size; } public function getSize() : string { return $this-&gt;size; } public function withSize(string $newSize) : House { return $this-&gt;copy('size', $newSize); } } And now you can use this class in a following way. $smallHouse = new House('small'); $bigHouse = $smallHouse-&gt;withSize('big'); echo $bigHouse-&gt;getSize(); \/\/writes 'big' echo $smallHouse-&gt;getSize(); \/\/writes 'small' as expected :) Copy trait made a solution from naive version much shorter and you don't have to change property visibility. Disadvantages? Well - almost none, but if you need &quot;getters&quot; and &quot;setters&quot; (in this case &quot;with'ers&quot;) it may be a sign that you didn't yet switch your thinking to functional. You should rather avoid changing a state of any value. Let's take a look a how you probably should deal with derivates of existing objects. The solution - Immutable DTO DDD teaches us that any value object is immutable and it comes hand in hand with functional programming . class House { \/** * @var string *\/ private $size; \/** * @var float *\/ private $someOtherField; public function __construct(string $size, float $someOtherField) { $this-&gt;size = $size; $this-&gt;someOtherField = $someOtherField; } public function getSize(): string { return $this-&gt;size; } public function getSomeOtherField(): float { return $this-&gt;someOtherField; } } This class does not contain anymore: setters, Copy trait, with'ers, cloning. How to use it properly? $smallHouse = new House('small', 14.234); $bigHouse = new House('big', $smallHouse-&gt;getSomeOtherField()); echo $bigHouse-&gt;getSize(); \/\/writes 'big' echo $smallHouse-&gt;getSize(); \/\/writes 'small' as expected :) What changed? Almost nothing. You still create a new instance of class House to create a value named $bigHouse. And you still create this value depending on already existing object $smallHouse, but this time it's more expressive and writting a code this way will probably make you think about overal structure of your solution in a way that you tend to use constructor just once, but with a well precalculated data instead of changing a values here and there.","tags":"","url":"Usage\/Essentials\/Copy_Trait.html"},{"title":"Option","text":"The problem Have you ever used null? Do you still use it? If the answer is yes - STOP IT. Even inventor of null agrees that null was a bad idea and excused a whole industry for this shortcut that leds thousand of developers around the world to a tons of costly bugs that could be easily avoided. How this problem usually looks like in a PHP development? Let's consider an example repository: public function findByEmail(string $email): ?User { return $this-&gt;findOneBy(['email' =&gt; $email]); } Apart from DDD good practices let's create an example controller action using this method. public function userByEmailAction(string $email): Resource { $user = $this-&gt;userRepository-&gt;findByEmail($email); if (is_null($user)) { return new Response([], HTTP_NOT_FOUND); } else { return new Response($user, HTTP_OK); } } Doesn't look good, does it? At least you have a nullable type indicator so you know if your function can return with null. Every user of a method findByEmail has to remember this fact fact and take care of handling null on his own. Even worse. Example displays a single usage of findByEmail method directly in userByEmailAction which is a controllers function, but keep in mind that you're going to have few layers of service between repository and controller and on every level you have to perform this check if it's a null or not. PHP developers did their homework and it's considered a good practice to write repository methods in a following way: public function findByEmail(string $email): User { $user = $this-&gt;findOneBy(['email' =&gt; $email]); if (!$user instanceof User) { throw new NotFoundException(&quot;oh my&quot;); } return $user; } and then in controller you'll see something like: public function userByEmailAction(string $email): Resource { try { return new Response($this-&gt;userRepository-&gt;findByEmail($email), HTTP_OK); } catch (NotFoundException $exception) { return new Response([], HTTP_NOT_FOUND); } } and this tree of possible exceptions to be handled tends to grow (a lot). But let's thing about it for a while. If you want to develop a functional code - where exeptions fit in a lamda calculus? The answer is - the don't. So think about it apart from functional programming. Go back to classical OOP principles. When you should use exceptions? You should use exceptions to sygnalize an error in you application runtime and change a normal flow of program execution. Rhetoric question: what kind of error is a situation when you can't find an entity in a database (DB connection works fine, DB is running, DB properly responds to your queries). The answer is - it's not an error and you should not use exceptions in such situation. A lack of object is an information itself. In our example: you need an information that your users table do not contain an user with a given email. The solution Option is one of the simplest monads (so simple, that you don't even have to understand a concept of monad to use it). Option let's you consciously handle existence and non-existence of some data without duct taping. How is Option implemented in PhpSlang? One picture is worth more than a thousand words. Option type is an abstract class. Most probably this is a type you want to return from functions or take as an argument. PhpSlang implementation of Option just makes use of a polymorphism and as you can see on a picture above there are two classes Some and None with a different implementations of methods map and getOrElse. As you may guess Some class in a kind of Option type which contains some value, while a None contains nothing. Speaking high level - you can map on Some, but you can also map on None - the only difference is that when you try to modify a content of None (so you try to modify nothing), then you... modify nothing (no effect). Sooner or later you want to get rid of a wrapping around you data and take it out of Option. You can do it with a getOrElse method which behaves in a different way, according to Option state (if it contains something or not). If your Option contains some data (so it is an instance of Some) then getOrElse will return you it's content. In case when your Option contains nothing (instance of None) the getOrElse method will just return it's first and only parameter (default value to return in case there is nothing to return). Repository example OK, let's take a look at our example. public function findByEmail(string $email) : Option { return Option::of($this-&gt;findOneBy(['email' =&gt; $email])); } We used Option::of static method to create Some or None according to $this-&gt;findOneBy(['email' =&gt; $email]) result (if it's null, we'll have None, otherwise Some). It's that simple. Now let's use this data: public function userByEmailAction(string $email): Resource { return $this-&gt;userRepository-&gt;findByEmail($email)) -&gt;map(function (User $user) { return new Response($user, HTTP_OK); }) -&gt;getOrElse(new Response('', HTTP_NOT_FOUND)); } As you see, we have only one return statement in a controller, all operations are chainable and you have this clarity of thinking you can't have with exceptions or when using null. More complicated example As you can read in this article monads are able to wrap eachother, and there also exist a possibility to flatten a structure of nested monads of the same kind. Let's consider that we have nested Options in our example. Take a look at example DTOs. class User { private $email; private $profile; public __construct( string $email, Option $profile ) { $this-&gt;email = $email; $this-&gt;profile = $profile; } public function getEmail(): string { return $this-&gt;email; } public function getProfile(): Option { return $this-&gt;profile; } } class Profile { private $address; private $phone; public __construct( Option $address, Option $phone ) { $this-&gt;address = $address; $this-&gt;phone = $phone; } public function getAddress(): Option { return $this-&gt;address; } public function getPhone(): Option { return $this-&gt;phone; } } class Address { private $street; private $buildingNumber; private $localNumber; public __construct( string $street, int $buildingNumber, Option $localNumber ) { $this-&gt;street = $street; $this-&gt;buildingNumber = $buildingNumber; $this-&gt;localNumber = $localNumber; } public function getStreet(): string { return $this-&gt;street; } public function getBuildingNumber(): int { return $this-&gt;buildingNumber; } public function getLocalNumber(): Option { return $this-&gt;localNumber; } } What we have here is a nested structure and we want to write a function that displays a local number. Keep in mind that: our repository can, but don't have to give us the user by email the user can, but don't have to have filled the profile data the profile data can, but don't have to contain the address information the address information can, but don't have to contain the local number First take a look at how it probably would look like if we would not use Option monad and just check null as usual: public function displayLocalNumber(string $email): string { $user = $this-&gt;userRepository-&gt;findByEmail($email)); if ( !is_null($user) &amp;&amp; !is_null($user-&gt;getProfile()) &amp;&amp; !is_null($user-&gt;getProfile()-&gt;getAddress()) &amp;&amp; !is_null($user-&gt;getProfile()-&gt;getAddress()-&gt;getLocalNumber())) { return 'Local number is: ' . $user-&gt;getProfile()-&gt;getAddress()-&gt;getLocalNumber(); } else { return 'No sufficient data'; } } And if you use Doctrine or other ORM\/ODM you can't be sure if every getter isn't actually a call to a database slowing down your application proportionally to network latency. So it would be safer to write a code above in a following way: public function displayLocalNumber(string $email): string { $user = $this-&gt;userRepository-&gt;findByEmail($email)); if (!is_null($user)) { $profile = $user-&gt;getProfile(); if (!is_null($profile)) { $address = $profile-&gt;getAddress(); if (!is_null($address)) { $localNumber = $address-&gt;getLocalNumber(); if (!is_null($localNumber)) { return 'Local number is: ' . $localNumber; } } } } return 'No sufficient data'; } Years of experience show that a problem above is usually even worse because developers tend to check null in a variety of ways so in some part of an applications you see is_null in other $val == null and few more variants in parts written by developers who don't work with you anymore. How to make this code less error prone and easier to reson about? How to make this ball of mud readable and extendible? Take a look at example using Option: public function displayLocalNumber(string $email): string { return $this-&gt;userRepository-&gt;findByEmail($email)) -&gt;flatMap(function(User $user): Option { return $user-&gt;getProfile(); }) -&gt;flatMap(function(Profile $profile): Option { return $profile-&gt;getAddress(); }) -&gt;flatMap(function(Address $address): Option { return 'Local number is: ' . $address-&gt;getLocalNumber(); }) -&gt;getOrElse('No sufficient data'); } What we did here? We run flatMap on every Option in a structure. This method has a similar implementation to map. It transform a content of Some or does nothing when you deal with None. The only difference is that value returned by an expression given as a flatMap parameter must return Option as well, so we can transform a structure like Option[Option[T]] into a Option[T] where T in our case can be User, then Profile then Address and then int. Other possibilities Option::of It is highly recommended that you create new Some('some content') and new None on your own when you have such possibility. But of course in a PHP world we have to deal with lots of existing code that may return an empty data in other ways. Method Option::of takes two parameters. 1st is a data to be passed to Some constructor when it has some content 2nd is an indicator of emptyness and its default value is null So if you want create a function which returns a None for empty array you may write a following function: function calculateAverage(array $inputData): float { return Option::of($inputData, []) -&gt;map(function(array $data): float { return array_sum($data) \/ count($data); }) -&gt;getOrElse(0.0); } This way you can calculate average value of elements of an array without fear you could feel when you see PHP Warning: Division by zero in php shell code on line ... in production logs. (btw. you don't have to implement average method on your own, it's build in in PhpSlang collection library). getOrElse vs getOrCall In all examples till this moment we used getOrElse method to fetch a default value of Option. Sometimes calculation of a default state is more complex that calculation of an existing state and you want to postpone or eliminate this calculation. In such case instead usage of method getOrElse it's recommended to use getOrCall which takes a function as a parameter. This function is run only when your Option is an instance of None Short example: function calculateAverage(array $inputData): float { return Option::of($inputData, []) -&gt;map(function(array $data): float { return array_sum($data) \/ count($data); }) -&gt;getOrCall(function(): float { return $this-&gt;veryComplicatedCalculations(); }); } isEmpty &amp; isNotEmpty Those two method names are self-explanatory. There are situations when you don't need Options content anymore and you just need an information if it has a content or not. isEmpty and isNotEmpty methods return a bool value. Unpack Option without $default value There may be a situation when you just want to unpack a content of Option monad without providing a default state. There is a method get() for this purpose. DANGER ZONE!!! Keep in mind that get will throw a NoContentException when it's an instance of None. At the moment there is only one known situation when using this method makes any sense. This case is using an Option monad as pipeline helper. You'll find more on this topic in tips and tricks section.","tags":"","url":"Usage\/Essentials\/Option.html"},{"title":"Either","text":"","tags":"","url":"Usage\/Essentials\/Either.html"},{"title":"Try","text":"","tags":"","url":"Usage\/Essentials\/Try.html"},{"title":"Future","text":"\/\/TODO: v0.3.0","tags":"","url":"Usage\/Essentials\/Future.html"},{"title":"Pattern Matching","text":"","tags":"","url":"Usage\/Pattern_Matching.html"},{"title":"Extractors","text":"\/\/Not Yet Implemented \/\/TODO: v0.2.0","tags":"","url":"Usage\/Extractors.html"},{"title":"Overview","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/Overview.html"},{"title":"List","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/List.html"},{"title":"Set","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/Set.html"},{"title":"HashMap","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/HashMap.html"},{"title":"Parallel Collections","text":"\/\/TODO: v0.3.0","tags":"","url":"Usage\/Immutable_Data_Structures\/Parallel_Collections.html"},{"title":"Basic Examples","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/Basic_Examples.html"},{"title":"More Examples","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/More_Examples.html"},{"title":"Memoization","text":"Problem\/possibility One of advantages (and principles) of functional programming is referential transparency. Ite means that a function run with an identical set of parameters should always return identical result. Putting things this way we can fast endup with a conclussion that there is no sense in complete execution of methods that were already used at leas once with the same set of parameters. This makes sense especially if computations performed by a given method are resource exhaustive. Consider a following example: class NonTrivialComputations { public function heavyComputations(string $name): int { \/\/it doesn't matter what this function does, but we know that: \/\/ 1 - it's pure function (no side effects, no external resources used) \/\/ 2 - computations may take a long time and we want to optimize this part } } Running such code will always lead to executing heavyComputations. Solution PHP does not give us any kind of tools to make this part easy (eg lazy val). To make your methods memoizable - you have to perform a little gymnastics: namespace PhpSlang\\Memoisation\\Memo; class NonTrivialComputations { \/** * @var Closure *\/ public $heavyComputations; public function __construct() { $this-&gt;heavyComputations = (new Memo)-&gt;memoize(function (string $name): int { return $this-&gt;heavyComputations($name); }; } private function heavyComputations(string $name): int { \/\/it doesn't matter what this function does, but we know that: \/\/ 1 - it's pure function (no side effects, no external resources used) \/\/ 2 - computations may take a long time and we want to optimize this part } } Our original method is private now and we created a class field of the same name which is publicly accessible. Then we assigned to this field a result of (new Memo)-&gt;memoize method which takes a new function as a parameter and this function has identical set of parameters as self::heavyComputations so we only pass a call. What we actually produced is a class with an object inside which will run our methods as previously, but when it's called again - already computed data will be returned. Dangerzone 1","tags":"","url":"Usage\/Memoization.html"},{"title":"Trampolines","text":"","tags":"","url":"Usage\/Trampolines.html"},{"title":"Common Mistakes","text":"Using call_user_func Using [call_user_func_array] is not recommended, but sometimes you may think it's impossible to live without it. One example may be a method with unspecified count of parameters. Lets consider a following example. function someFunc() { $args = func_get_args(); \/\/ do something } call_user_func_array('someFunc',array('one','two','three')); 1st - it's a bad idea to use func_get_args as well. 2nd - example above can be transformed to: function someFunc() { $args = func_get_args(); \/\/ do something } someFunc(...['one','two','three']); Or even better to: function someFunc(...$args) { \/\/ do something } someFunc('one','two','three'); Shorter, more readable and less bug prone.","tags":"","url":"Good_Practices\/Common_Mistakes.html"},{"title":"Pipelineing","text":"The problem When you develop in a functional style you tend to create a lot of small functions than can be composed. Lets consider a following example: class ALotOfNestedFunctionCallsExample { \/\/it doesn't matter what those functions do internally abstract protected function transformation1(TypeA $input): TypeB; abstract protected function transformation2(TypeB $input): TypeC; abstract protected function transformation3(TypeC $input): TypeD; abstract protected function transformation4(TypeD $input): TypeE; public function giveMeSomeThingInteresting(TypeA $input): TypeE { return $this-&gt;transformation4( $this-&gt;transformation3( $this-&gt;transformation2( $this-&gt;transformation1($input) ) ) ); } } Method giveMeSomeThingInteresting returns a value which is a result of nested function calls. In a given example it's quite readable becaue functions transformation1, transformation2, transformation3, transformation4 take only one parameter, but it's easy to imagine that every one of them take some other additional arguments and this whole tree of nested calls get quite messy. What you would do in such situation in languages like Haskell, Erlang\/Elixir or F# you'd most probably use a pipeline operator (Elixir example). If ther would be an easy way to pipe operations in PHP example above would change into: class ALotOfNestedFunctionCallsExample { \/\/it doesn't matter what those functions do internally abstract protected function transformation1(TypeA $input): TypeB; abstract protected function transformation2(TypeB $input): TypeC; abstract protected function transformation3(TypeC $input): TypeD; abstract protected function transformation4(TypeD $input): TypeE; public function giveMeSomeThingInteresting(TypeA $input): TypeE { return $this-&gt;operation1($input) |&gt; $this-&gt;operation2($$) |&gt; $this-&gt;operation3($$) |&gt; $this-&gt;operation4($$); } } But PHP does not support such construct at the moment. Such functionality was proposed in PHP RFC: Pipe Operator at 2016-04-29, but it's not yet implemented. So how can you get over it at the moment? Use Option in a non-typical way. class ALotOfNestedFunctionCallsExample { \/\/it doesn't matter what those functions do internally abstract protected function transformation1(TypeA $input): TypeB; abstract protected function transformation2(TypeB $input): TypeC; abstract protected function transformation3(TypeC $input): TypeD; abstract protected function transformation4(TypeD $input): TypeE; public function giveMeSomeThingInteresting(TypeA $input): TypeE { return (new Some($this-&gt;operation1($input)) -&gt;map(function(TypeB $inp): TypeC { return $this-&gt;operation2($inp); }) -&gt;map(function(TypeC $inp): TypeD { return $this-&gt;operation3($inp); }) -&gt;map(function(TypeD $inp): TypeE { return $this-&gt;operation4($inp); }) -&gt;get(); } } And with extractors this can be squeezed to: class ALotOfNestedFunctionCallsExample { \/\/it doesn't matter what those functions do internally abstract protected function transformation1(TypeA $input): TypeB; abstract protected function transformation2(TypeB $input): TypeC; abstract protected function transformation3(TypeC $input): TypeD; abstract protected function transformation4(TypeD $input): TypeE; public function giveMeSomeThingInteresting(TypeA $input): TypeE { return (new Some($this-&gt;operation1($input)) -&gt;map(E($this)-&gt;operation2()) -&gt;map(E($this)-&gt;operation3()) -&gt;map(E($this)-&gt;operation4()) -&gt;get(); } }","tags":"","url":"Good_Practices\/Tips_and_tricks\/Pipelineing.html"},{"title":"Top 10 Sins of PHP","text":"Top 10 sins of PHP PHP is a mature language yet it has it downsides especially in terms of functional programming (but not only). Purpouse of a following article is pointing out some problems you'll face when you'll start to code functionally (but not only). Short note: Following article compare PHP with other functional languages. Scala is given as an example but this language was picket from tons of other languages because of its popularity. Please don't take a false assumption that a basic meaning of this article is that PHP should become Scala. PHP isn't Scala and will never be and probably should'nt become one. It has it's own upsides, but this article is focused on downsides - especially in context of functional programming and gives some answers on PhpSlang purpose and history. 1. Verbose anonymous function syntax When you start to program functionally with PHP you will create new functions - a lot. And most of pure functions should contain only one return statement. Let's take a look at a following example. $users -&gt;map(function(User $user) : string { return $user-&gt;getFirstName(); }); All this simple piece of code does is transforming a list of users into a list of first names of those users. Now let's slim down this example and cut all redundant information step by step. So first - we don't need a return statement because pure functions perform only one operation or at least we could assume that a result of a last statement in a function should be returned. This is what most Scala, or even Ruby does. So this example could become: $users -&gt;map(function(User $user) : string { $user-&gt;getFirstName(); }); We also do not need a semicolons when we think about our code this way. $users -&gt;map(function(User $user) : string { $user-&gt;getFirstName() }) Third part is function keyword. We know that map() should receive a function as a 1st parameter and what we will have is still more than we need to know that this is a function definition. $users -&gt;map((User $user) : string { $user-&gt;getFirstName() }) Next part of downsizing. Take a look at curly brackets. It's quite obvious that before arguments and returned type definition there should appear actual implementation. $users -&gt;map((User $user) : string $user-&gt;getFirstName()) Just look at it. This code could all fit in a single line of code. And because we treat functions as immutable values for object we dont need brackets for functions with arity 0 (functions that take 0 arguments). $users -&gt;map((User $user) : string $user-&gt;getFirstName) We could as well remove type annotations (but it's not a good idea as long as point 2 of this list is still valid). $users -&gt;map(($user) $user-&gt;getFirstName) But all those code examples is just a fantasy. With PHP till this moment we have to stick with: $users -&gt;map(function(User $user) : string { return $user-&gt;getFirstName(); }); This is the same functionality implemented with a Scala for comparision (yes it's a working code). users .map(user =&gt; user.getFirstName) 2. No generic types Lack of generic types touches not only developers who want to introduce functional programming. This is a problem of a whole community and everyone who created non trivial OOP application feel this problem. On 2016-01-06 there was introduced a proposal to implement this feature. More about a proposal and shape of eventual implementation in PHP you can find at https:\/\/wiki.php.net\/rfc\/generics Fervo set a bounty for this feature: https:\/\/www.bountysource.com\/issues\/20553561-add-generics-support\/backers You can ask yourself how such feature could change my life? Well lets consider you have want to pass a list of some object to your method. function listTransformer(ListCollection $someList); OK, so we have a list. But a list of what? There is no way to define such info. You can (and should) of course try with describing content of iterables inside dockblock. \/** * @param ListCollection|User[] $someList *\/ function listTransformer(ListCollection $someList); So now we now that this parameter had to keep User entities. Some tools will handle it somehow, some not. The worst part is that such annotation has completely no impact on how our code will be executed. Dockblock annotation helps only for iterables - how about other generic methods and classes? There is no easy answer at the moment. All this mess could be resolved when we could write type definition similar to: function listTransformer(ListCollection&lt;User&gt; $someList); Remember that generics are also composable so with generic types you could define more complicated structures. Take a look at following example in Scala (you can achieve very similar things with Java or C++ as well). def searchArticles(String searchQuery) : Either&lt;List&lt;Article&gt;, SearchError&gt; Such definition in PHP at the moment is limited to: function searchArticles(string $searchQuery) : Either; And you as a developer have to remember that Either should contain ListCollection of Article's or SearchError entity with detailed information about what happened wrong. 3. Convenient reassignments When you decide to create purely functional code with PHP it will require a lot of discipline on your side. And there is no way to stop other team members from breaking your convention. There are no tools to prevent you from reassignments. Maybe some day PHPMD will be enriched with such functionality but such features are'nt listed in it's roadmap at the moment. Even worse - reassignments can occur even by a mistake. Take a look at following example. $pleaseIDontWantToBecomeMutant = 'regular human'; $someList = [1, 2, 3]; foreach ($someList as $pleaseIDontWantToBecomeMutant) { \/\/do nothing } echo $pleaseIDontWantToBecomeMutant; What do you think what will be the value of a $pleaseIDontWantToBecomeMutant? Hint: definitely not a regular human. Referential non-transparency Next example. Some developer are very greedy in terms of memory (and they have their reasons). You probably used a lot of 3rd party libraries or even build-in functions taking arguments via reference. $cow = 'cow'; $chernobylFunction = function(&amp;$someArgument) { $someArgument = 'cow producing eggs'; return $someArgument; }; echo $chernobylFunction($cow); echo $cow; A sad result of this code is that $chernobylFunction will return cow producing eggs as expected, but a regular $cow will become cow producing eggs as well (and you'll see this problem on production if you don't write enough tests). And our regular cow is lost - no more milk. When you are a creator of such function you may think - I have it all under control. The problem is that users of that function don't. As a library user you have to be very careful and check every function definition if it's arguments are passed by a copy or a reference. 4. Inconvenient cloning Take a look at this class. class House { \/** * @var string *\/ private $size; public function __construct(string $size) { $this-&gt;size = $size; } public function getSize() : string { return $this-&gt;size; } public function setSize(string $newSize) : House { $this-&gt;size = $newSize; return $this; } } Nothing special isn't it? Regular class with getters and setters like we're used to have. Method setSize returns $this so we have a convenient way to chain few method for one object. Let's consider a following usage. $smallHouse = new House('small'); $bigHouse = $smallHouse-&gt;setSize('big'); echo $bigHouse-&gt;getSize(); \/\/writes 'big' echo $smallHouse-&gt;getSize(); \/\/writes 'big' as well :( What happened? We mutated a state again - somehow by an accident. OK, so you transform your code so it's purely functional. Let's say that You already read a PhpSlang documentation and you know that every function name with set as a prefix should become a similar function with with as a prefix. How to achieve it? If you used Scala such method would look somehow like: case class House(size:Int) { def withSize(newSize : Int) = copy(size = newSize) } PHP does not provide any build in features to clone objects with only selected fields changes, so you end up creating completely new objects copying all fields to constructor and changing those values you're interested in or with class which looks like this: class House { \/** * @var string *\/ public $size; public function __construct(string $size) { $this-&gt;size = $size; } public function getSize() : string { return $this-&gt;size; } public function withSize(string $newSize) : House { $clone = clone $this; $clone-&gt;size = $newSize; \/\/note that $size field had to be changed to public return $clone; } } Does'nt look very beautiful is it? PhpSlang's Copy trait partially resolves this issue and allows you to write something like: class House { use Copy; \/** * @var string *\/ private $size; public function __construct(string $size) { $this-&gt;size = $size; } public function getSize() : string { return $this-&gt;size; } public function withSize(string $newSize) : House { return $this-&gt;copy('size', $newSize); } } And now you can use this class in a following way. $smallHouse = new House('small'); $bigHouse = $smallHouse-&gt;withSize('big'); echo $bigHouse-&gt;getSize(); \/\/writes 'big' echo $smallHouse-&gt;getSize(); \/\/writes 'small' as expected :) 5. Very little syntactic sugar No placeholder syntax No partially applied functions No implicit scoping No wildcard import No pipeline operator https:\/\/wiki.php.net\/rfc\/pipe-operator 6. Imperative ecosystem 7. Lack of Closure descriptions 8. No pattern matching 9. No macros 10. No standard for annotations","tags":"","url":"Additional_Articles\/Top_10_Sins_of_PHP.html"},{"title":"Roadmap","text":"PhpSlang is still a work in progress - please refer to this page to keep track of crucial features. 0.1.0 [x] Option monad [x] Either monad [x] Copy trait [x] Immutable List collection [x] Trampolines [x] Pattern matching 0.2.0 [x] Tuples [X] Memoization [_] Immutable HashMap collections [_] Immutable Set collections [_] Extractors [_] Try monad 0.3.0 [_] TraversableCollection 0.7.0 [_] Convenient enumeration 0.4.0 [_] Future monad 0.5.0 [_] Parallel immutable List collection [_] Parallel immutable HashMap collection [_] Parallel immutable Set collection 0.6.0 [_] Validation functor [_] Property testing [_] Numeric type with infinite precision 0.8.0 [_] Doctrine integration [_] Symfony bundle 0.?.? [_] Lenses [_] Kleisli algebra","tags":"","url":"General\/Roadmap.html"},{"title":"Other Resources","text":"PhpSlang Presentations Why async and functional programming in PHP7 suck and how to get overr it? (slides only) PHP FP in general Presentations Mark Baker: A Functional Guide to Cat Herding with PHP Generators VIDEO, SLIDES","tags":"","url":"General\/Other_Resources.html"},{"title":"License","text":"The MIT License (MIT) Copyright (c) 2016 Witold Adamus Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","tags":"","url":"General\/License.html"}]}