{"pages":[{"title":"PhpSlang","text":"PhpSlang - Functional PHP the right way Library code and this documentation are distributed under MIT License. Installation &amp; requirements PhpSlang is super easy to install and it has no externall dependencies except a PHP7+ Install with composer: composer install php-slang\/php-slang That's all! You are ready to go! Now it's highly recomended to read a whole documentation. This documentation was created not only to describe a PhpSlang library, but also to give you a good, smooth introduction to purely functional programming in general.","tags":"","url":"index.html"},{"title":"Thinking Functional","text":"Why? Functional programming became a buzzword of all software conferences in few last years. PHP community does it's best to keep pace because there is a lot to gain. What are the biggest benefits of functional programming? Less bugs Maintainable code Scalability out of box Easier testing Shorter code Easy to learn You gain all of this by switching to FP (and PhpSlang will help you with it). Take all of these advantages for granted at the moment - we will cover points above in a while. Short intro Some people say that when you want to learn program functionally you have to forget everything you know about programming and go back to school and your math teacher should be your programming master from this day. There's a lot of truth in such thinking, but not completely - eg. OOP and FP create a great couple so all you know about inheritance, composition etc. is still on the menu. Staring to code purely functional does not discard all good practices like DRY, SOLID, YAGNI neither. Even more - if you're familiar with Domain Driven Design - you'll see that functional thinking can be applied not only to specific pieces of code, but to the architectural decisions as well. See this great Greg Young's talk for a reference (if you ask yourself what event sourcing has to do with DDD check out Eric Evans book). The problem (with imperative programming) Every day headache Does this story feel familiar to you? Or bunch of other funny pictures about developers struggling with NullPointerExceptions or OutOfBoundExceptions? There are tons of everyday small glitches in our projects. Sometimes such problems are resolved at code review when other developers in your team find it, sometimes on production instance when angry clients start to call a support line. We have to keep in mind lots of tiny dependencies that sum up to huge graph of connections which most developers have to keep in mind when maintaining existing code. The problem is that we are just humans and our buffer is quite tiny and easy to flush. Scalability issues How many simultaneous threads with concurrent access to your data you're able to implement with full confidence? 2? 10? 20? What would you say about 100000? It is possible with pure functions. With shared mutable state not. And scalability is just one dimension of a whole problem. Mutability is counterintuitive The business requirements tend to grow and change. FP won't solve all your problems with complexity but will not create separate complexity on it's own and using immutable data structures and monads will help you handle this complexity. Imperative style can seem like a standard way of giving your computer instructions to process. That's how computers work - instruction after instruction, are'nt they? Well maybe (as long we're using Von Neumann computers) but it's definitely not how human brains work and not how the world around us works. Do you remember when the last time some physical object in your surrounding was just reasigned? The solution 1. Immutability! The biggest difference between eg. Haskell and PHP is that you CAN NOT reassign values. Keeping immutability will require a lot more discipline on your side when you use PHP, but syntax in not important - thinking is! From this day just keep in mind that: There is no such thing as variable! Forget about changing state of variables in random places. All your code should be build of small logical blocks which are: Easy to reason about Every function should return the same result when run with the same set of input data. This way you don't have to think about tons of dependencies inside your code. When you want to do something - you just run a function and you can be sure that it will behave in the same way every time. 2. Ask a right questions Imperative paradigm which is a standard for most of PHP applications leaves you with a code that describes HOW TO achieve things. Functional paradigm leaves you with a code that describes WHAT you want to achieve. 3. Function as a first class citizen It must be mentioned because - well it's a functional programming. Points below are rather a technical detail - but when you have these tools, completely new possibilities are open for you. Currying - functions can return another functions as well. Higher order functions - functions can be passed as arguments to other functions. Anonymous functions - you can define a function just in a place you use them. Functions can be assigned to a variable (and object scope as well). Pros Less bugs Immutability - again. Lets consider a following linear function you can remember from your childhood: f(x) = x * 2 When x equals 2 you just know that the result of computation is 4. When 6 it's 12, when 7 it's 14 and so on. More important than what this function does is what this function DOES NOT. This function DOES NOT: set any kind of variables which are reused in next executions add new objects to globally available array create a temporary array to accumulate computed data This is just a simple example, but it's actually an ultimate point of FP. Maintainable code Code describes WHAT it does, not HOW. So you don't have to think that much on what was the intention of a developer who created this piece of code - this information is already here. Having a project written in a purely functional manner means also easier debugging and code navigation. As long as all function calls are explicit, you'll see very little or no surprises when debugging. Scalability out of box The biggest challenge of distributed architecture is concurrent access to data. You never know if a state is up to date and who uses specific entities at the moment. Concurrency creates tons of problems which can be solved using ideas like locks, mutexes, semaphores etc. but it requires a lot of effort and creates new problems you have to keep in mind when extending existing solutions. With immutable code and immutable data structures you can forget about all this stuff. When result of a function is the same every time, there is no risk of running it in parallel on few CPU cores or even few physical machines. You don't share a memory so code is not only more predictable but simply works faster. Check Future and Parallel Collections for more information on this topic. Easier testing No initialization. No tests for various states of dependent variables. No side effects checks. Much less mocking and stubbing. Just simple checks for return value and domain specific edge cases. And again: TDD and BDD are still on the menu. Shorter code When you use nested function calls you end up with a much more condensed code. Pipelined calls also tend to take less space and when everything is immutable, most of your functions contain only one return statement - which appears in a first line of a method (yes braces, semicolon and return keyword become to seem redundant - but unfortunately you still have to use them in PHP). Code condensation is visible especially for immutable collections - when you chain eg. map() and filter() calls it becomes readable even for people with no developing skills. Easy to learn One of the biggest myths of functional programming is that it has a big entry level. Source of such a belief can be found in a track of life of an experienced software developers. They are used to see small increments. When you develop with Zend for 3 years and then jump to Symfony - most of concepts are the same, only approach to solve problems is different. Functional programming requires you to really change the way you think (and it can be painful at the beginning), but it's really not that much to learn (there's actually less things you have to learn to start compared to OOP). When currying and monads give you a headache remember days when questions like 'what is a difference between interface and abstract class' were hard to answer for you - you have to fill the gaps in your knowledge but from a perspective it's actually not that hard. OK, but my app has to store user input. It can seem like a not so easy question to answer keeping in mind that all materials about FP repetitively convince you not mutate data at all, but it does'nt mean that FP is limited only to transform data without side effects. For an average PHP developer the simple answer is - store all your state changes in a database. That is the only place where data changes should happen. Immutability also does'nt mean that you cant create eg. database engine with purely functional language - check Haskel's STM for a reference. There's also a high chance that you are familiar with RabbitMQ which is written in Erlang. There is a lot of other software written in purely functional languages which are capable of storing varying data, only approach to data changes is different. Show me the code It's a prolixity without showing the code, so let's see this small example. Both functions below return the same result for identical input. The only difference is used paradigm. Imperative implementation: &lt;?php function averageOfNumbersSmallerThan(array $numbers, int $threshold) : string { $numbersSmallerThanThreshold = []; foreach ($numbers as $number) { if ($number &lt;= $threshold) { $numbersSmallerThanThreshold[] = $number; } } $numbersDividedByThree = []; foreach ($numbersSmallerThanThreshold as $number) { $numbersDividedByThree = $number \/ 3; } $average = null; if (count($numbersDividedByThree) &gt; 0) { foreach ($numbersDividedByThree as $number) { if (is_null($average) { $average = $number; } else { $average = ($average + $number) \/ 2; } } } if (is_null($average) { return 'It\\'s impossible to count average for a given data.'; } else { return 'Average is: ' . $average; } } ?&gt; Functional implementation (using PhpSlang): &lt;?php function averageOfNumbersSmallerThan(ListCollection $numbers, int $threshold) : string { return $numbers -&gt;filter(function($number) use ($threshold) { return $number &lt;= $threshold; }) -&gt;map(function($number) { return $number \/ 3; }) -&gt;avg() -&gt;map(function($avg) { return 'Average is: ' . $avg; }) -&gt;getOrElse('It\\'s impossible to count average for a given data.'); } ?&gt; Summing things up Does an example above look convincing? It's just a beginning. Remember that this example describes only one method and we're just scrapping the surface here. We did'nt even touched the danger zones of exception handling, mutable object fields, validation and any kind of storage. The most important facts to remember before reading other materials on functional programming are: immutability - lets you deal with complexity and helps you create code which won't surprise you WHAT not HOW - this is the question that should be answered by your code treat function as a first class citizen - your system is composed of functions - they deserve some respect. Have fun with functional programming!","tags":"","url":"Introduction\/Thinking_Functional.html"},{"title":"Fast Introduction To FP In PHP","text":"","tags":"","url":"Introduction\/Fast_Introduction_To_FP_In_PHP.html"},{"title":"Dont be afraid of monads","text":"","tags":"","url":"Introduction\/Dont_be_afraid_of_monads.html"},{"title":"Sins of PHP","text":"PHP is not perfect Verbose syntax No placeholder syntax No partially applied functions No implicit scoping No wildcard import Lack of Closure descriptions Convenient reassignments Inconvenient cloning Poor tooling and documentation Imperative ecosystem No generic types No pattern matching No macros No standard for annotations","tags":"","url":"Introduction\/Sins_of_PHP.html"},{"title":"PhpSlang Internal Structure","text":"","tags":"","url":"Introduction\/PhpSlang_Internal_Structure.html"},{"title":"FAQ","text":"I read a documentation and did'nt found an answer. PhpSlang treads unclear documentation as a bug. If you have any issues with understanding described concepts or something is missing or misleading - feel free to create an issue on Github Where to start with functional programming? Honestly - not with PHP. Give a chance to Scala, Haskell, or Elixir. All great ideas you'll learn out there will change the way you use PHP, but it requires a lot of discipline to write immutable, purely functional code in PHP (and PhpSlang helps you here). It can sound a little bossy but at the moment PhpSlang documentation seems to be the most comprehensive guide on functional programming in PHP. There are of course other resources and they are listed on Other resources page. When not to use functional programming? Your default approach should be - write everything functionally. I promise, when you learn to write purely functional code there is no coming back. You'll want to write everything this way and when you'll face a problem which requires different approach you'll see this. There is no specific business domain where FP or traditional OOP is better. But keep in ming that a gold hammer does'nt exist. There are two fields of a reality where there is a common belief that FP performs worse: Embedded devices - when you write code for AVR or PIC microcontrollers and every bit of a memory matters - then it's probably best to stick with a classical C development. Sorting algorithms - there's a whole story behind a quick sort implementations for a variety of functional languages and benchmarks show that because of a mutational nature of quick sort it performs worse when implementation in a purely functional way. How about things you can't implement with functional approach? If you found such problem please let us know on Gitter chat. We'll be more that happy to help you solve the problem. If you have such issue it can indicate some bugs or shortages of PhpSlang. Why some parts of PhpSlang are not purely functional? It can seem like a lack of consequence, but keep in mind a main goal of a whole project. It was created to give PHP developers tools that will enable them to benefit from functional approach in a convenient way. It hides some ugly parts of PHP. Those ugly parts are still there, but with PhpSlang you don't have to deal with them every time you want to do something. How about mixing PhpSlang with other libraries? PhpSlang does'nt change a behaviour of PHP nor adds any kind of special keywords. It just provides helpful classes and functions. It's still PHP so you can mix approaches. If you want to have consistent code style - it's good to wrap\/extend existing libraries with PhpSlang constructs eg. Option::of() for all calls returning nullable results. I use library X and it returns different results when used along with PhpSlang. There is a high chance that one of two things happened: results of computations were wrong previously, but now with FP you fixed some bugs by an accident (such magical things happen when you force yourself to formalize every aspect of an application) results of computations were correct previously, but now are wrong - it probably indicated non-thread-safe code. Some libraries highly depend on mutations (even worse on mutations of static fields or globally accessible variables). This way in a middle of computations in method A, you change a state needed by method B. Please check if switching from ParallelListCollection (or other parallel collection) to ListCollection won't solve your problem. TL;DR look for race condition. I found a bug. Place an issue on Github so we know it exists. It will be fixed ASAP. I want to use it in a commercial project Feel free - it's distributed under MIT License. When feature X will be available? See Roadmap for a reference.","tags":"","url":"Introduction\/FAQ.html"},{"title":"Copy Trait","text":"","tags":"","url":"Usage\/Essentials\/Copy_Trait.html"},{"title":"Curried Objects","text":"","tags":"","url":"Usage\/Essentials\/Curried_Objects.html"},{"title":"Option","text":"","tags":"","url":"Usage\/Essentials\/Option.html"},{"title":"Either","text":"","tags":"","url":"Usage\/Essentials\/Either.html"},{"title":"Try","text":"","tags":"","url":"Usage\/Essentials\/Try.html"},{"title":"Future","text":"","tags":"","url":"Usage\/Essentials\/Future.html"},{"title":"Pattern Matching","text":"","tags":"","url":"Usage\/Pattern_Matching.html"},{"title":"Extractors","text":"","tags":"","url":"Usage\/Extractors.html"},{"title":"Overview","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/Overview.html"},{"title":"Parallel Collections","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/Parallel_Collections.html"},{"title":"Basic Examples","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/Basic_Examples.html"},{"title":"More Examples","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/More_Examples.html"},{"title":"Operation Chaining","text":"","tags":"","url":"Usage\/Operation_Chaining.html"},{"title":"Enumeration","text":"","tags":"","url":"Usage\/Enumeration.html"},{"title":"Memoization","text":"","tags":"","url":"Usage\/Memoization.html"},{"title":"Validation And Property Testing","text":"","tags":"","url":"Usage\/Validation_And_Property_Testing.html"},{"title":"Trampolines","text":"","tags":"","url":"Usage\/Trampolines.html"},{"title":"Error Handling","text":"","tags":"","url":"Good_Practices\/Error_Handling.html"},{"title":"Dealing With Legacy Code","text":"","tags":"","url":"Good_Practices\/Dealing_With_Legacy_Code.html"},{"title":"Common Mistakes","text":"","tags":"","url":"Good_Practices\/Common_Mistakes.html"},{"title":"Roadmap","text":"PhpSlang is still a work in progress - please refer to this page to keep track of crucial features. 0.1.0 [x] Option monad [x] Either monad [x] Copy trait [x] Immutable List collection [x] Trampolines [x] Pattern matching 0.2.0 [x] Tuples [_] Immutable HashMap collections [_] Immutable Set collections [_] Extractors [_] Try monad 0.3.0 [_] Future monad [_] Parallel immutable List collection [_] Parallel immutable HashMap collection [_] Parallel immutable Set collection 0.4.0 [_] Validation functor [_] Property testing [_] Numeric type with infinite precision 0.5.0 [_] Lazy monad \/ Memoization [_] Chainable\\pipe monad [_] Convenient enumeration 0.6.0 [_] Doctrine integration [_] Symfony bundle","tags":"","url":"General\/Roadmap.html"},{"title":"Other Resources","text":"","tags":"","url":"General\/Other_Resources.html"},{"title":"License","text":"The MIT License (MIT) Copyright (c) 2016 Witold Adamus Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","tags":"","url":"General\/License.html"}]}