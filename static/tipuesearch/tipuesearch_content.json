{"pages":[{"title":"PhpSlang","text":"PhpSlang - Functional PHP the right way Library code and this documentation are distributed under MIT License. Installation &amp; requirements PhpSlang is super easy to install and it has no externall dependencies except a PHP7+ Install with composer: composer install php-slang\/php-slang That's all! You are ready to go! Now it's highly recomended to read a whole documentation. This documentation was created not only to describe a PhpSlang library, but also to give you a good, smooth introduction to purely functional programming in general.","tags":"","url":"index.html"},{"title":"Thinking Functional","text":"Why? Functional programming became a buzzword of all software conferences in few last years. PHP community does it's best to keep pace because there is a lot to gain. What are the biggest benefits of functional programming? Less bugs Maintainable code Scalability out of box Easier testing Shorter code Easy to learn You gain all of this by switching to FP (and PhpSlang will help you with it). Take all of these advantages for granted at the moment - we will cover points above in a while. Short intro Some people say that when you want to learn program functionally you have to forget everything you know about programming and go back to school and your math teacher should be your programming master from this day. There's a lot of truth in such thinking, but not completely - eg. OOP and FP create a great couple so all you know about inheritance, composition etc. is still on the menu. Staring to code purely functional does not discard all good practices like DRY, SOLID, YAGNI neither. Even more - if you're familiar with Domain Driven Design - you'll see that functional thinking can be applied not only to specific pieces of code, but to the architectural decisions as well. See this great Greg Young's talk for a reference (if you ask yourself what event sourcing has to do with DDD check out Eric Evans book). The problem (with imperative programming) Every day headache Does this story feel familiar to you? Or bunch of other funny pictures about developers struggling with NullPointerExceptions or OutOfBoundExceptions? There are tons of everyday small glitches in our projects. Sometimes such problems are resolved at code review when other developers in your team find it, sometimes on production instance when angry clients start to call a support line. We have to keep in mind lots of tiny dependencies that sum up to huge graph of connections which most developers have to keep in mind when maintaining existing code. The problem is that we are just humans and our buffer is quite tiny and easy to flush. Scalability issues How many simultaneous threads with concurrent access to your data you're able to implement with full confidence? 2? 10? 20? What would you say about 100000? It is possible with pure functions. With shared mutable state not. And scalability is just one dimension of a whole problem. Mutability is counterintuitive The business requirements tend to grow and change. FP won't solve all your problems with complexity but will not create separate complexity on it's own and using immutable data structures and monads will help you handle this complexity. Imperative style can seem like a standard way of giving your computer instructions to process. That's how computers work - instruction after instruction, are'nt they? Well maybe (as long we're using Von Neumann computers) but it's definitely not how human brains work and not how the world around us works. Do you remember when the last time some physical object in your surrounding was just reasigned? The solution 1. Immutability! The biggest difference between eg. Haskell and PHP is that you CAN NOT reassign values. Keeping immutability will require a lot more discipline on your side when you use PHP, but syntax in not important - thinking is! From this day just keep in mind that: There is no such thing as variable! Forget about changing state of variables in random places. All your code should be build of small logical blocks which are: Easy to reason about Every function should return the same result when run with the same set of input data. This way you don't have to think about tons of dependencies inside your code. When you want to do something - you just run a function and you can be sure that it will behave in the same way every time. 2. Ask a right questions Imperative paradigm which is a standard for most of PHP applications leaves you with a code that describes HOW TO achieve things. Functional paradigm leaves you with a code that describes WHAT you want to achieve. 3. Function as a first class citizen It must be mentioned because - well it's a functional programming. Points below are rather a technical detail - but when you have these tools, completely new possibilities are open for you. Currying - functions can return another functions as well. Higher order functions - functions can be passed as arguments to other functions. Anonymous functions - you can define a function just in a place you use them. Functions can be assigned to a variable (and object scope as well). Pros Less bugs Immutability - again. Lets consider a following linear function you can remember from your childhood: f(x) = x * 2 When x equals 2 you just know that the result of computation is 4. When 6 it's 12, when 7 it's 14 and so on. More important than what this function does is what this function DOES NOT. This function DOES NOT: set any kind of variables which are reused in next executions add new objects to globally available array create a temporary array to accumulate computed data This is just a simple example, but it's actually an ultimate point of FP. Maintainable code Code describes WHAT it does, not HOW. So you don't have to think that much on what was the intention of a developer who created this piece of code - this information is already here. Having a project written in a purely functional manner means also easier debugging and code navigation. As long as all function calls are explicit, you'll see very little or no surprises when debugging. Scalability out of box The biggest challenge of distributed architecture is concurrent access to data. You never know if a state is up to date and who uses specific entities at the moment. Concurrency creates tons of problems which can be solved using ideas like locks, mutexes, semaphores etc. but it requires a lot of effort and creates new problems you have to keep in mind when extending existing solutions. With immutable code and immutable data structures you can forget about all this stuff. When result of a function is the same every time, there is no risk of running it in parallel on few CPU cores or even few physical machines. You don't share a memory so code is not only more predictable but simply works faster. Check Future and Parallel Collections for more information on this topic. Easier testing No initialization. No tests for various states of dependent variables. No side effects checks. Much less mocking and stubbing. Just simple checks for return value and domain specific edge cases. And again: TDD and BDD are still on the menu. Shorter code When you use nested function calls you end up with a much more condensed code. Pipelined calls also tend to take less space and when everything is immutable, most of your functions contain only one return statement - which appears in a first line of a method (yes braces, semicolon and return keyword become to seem redundant - but unfortunately you still have to use them in PHP). Code condensation is visible especially for immutable collections - when you chain eg. map() and filter() calls it becomes readable even for people with no developing skills. Easy to learn One of the biggest myths of functional programming is that it has a big entry level. Source of such a belief can be found in a track of life of an experienced software developers. They are used to see small increments. When you develop with Zend for 3 years and then jump to Symfony - most of concepts are the same, only approach to solve problems is different. Functional programming requires you to really change the way you think (and it can be painful at the beginning), but it's really not that much to learn (there's actually less things you have to learn to start compared to OOP). When currying and monads give you a headache remember days when questions like 'what is a difference between interface and abstract class' were hard to answer for you - you have to fill the gaps in your knowledge but from a perspective it's actually not that hard. OK, but my app has to store user input. It can seem like a not so easy question to answer keeping in mind that all materials about FP repetitively convince you not mutate data at all, but it does'nt mean that FP is limited only to transform data without side effects. For an average PHP developer the simple answer is - store all your state changes in a database. That is the only place where data changes should happen. Immutability also does'nt mean that you cant create eg. database engine with purely functional language - check Haskel's STM for a reference. There's also a high chance that you are familiar with RabbitMQ which is written in Erlang. There is a lot of other software written in purely functional languages which are capable of storing varying data, only approach to data changes is different. Show me the code It's a prolixity without showing the code, so let's see this small example. Both functions below return the same result for identical input. The only difference is used paradigm. Imperative implementation: &lt;?php function averageOfNumbersSmallerThan(array $numbers, int $threshold) : string { $numbersSmallerThanThreshold = []; foreach ($numbers as $number) { if ($number &lt;= $threshold) { $numbersSmallerThanThreshold[] = $number; } } $numbersDividedByThree = []; foreach ($numbersSmallerThanThreshold as $number) { $numbersDividedByThree = $number \/ 3; } $average = null; if (count($numbersDividedByThree) &gt; 0) { foreach ($numbersDividedByThree as $number) { if (is_null($average) { $average = $number; } else { $average = ($average + $number) \/ 2; } } } if (is_null($average) { return 'It\\'s impossible to count average for a given data.'; } else { return 'Average is: ' . $average; } } ?&gt; Functional implementation (using PhpSlang): &lt;?php function averageOfNumbersSmallerThan(ListCollection $numbers, int $threshold) : string { return $numbers -&gt;filter(function($number) use ($threshold) { return $number &lt;= $threshold; }) -&gt;map(function($number) { return $number \/ 3; }) -&gt;avg() -&gt;map(function($avg) { return 'Average is: ' . $avg; }) -&gt;getOrElse('It\\'s impossible to count average for a given data.'); } ?&gt; Summing things up Does an example above look convincing? It's just a beginning. Remember that this example describes only one method and we're just scrapping the surface here. We did'nt even touched the danger zones of exception handling, mutable object fields, validation and any kind of storage. The most important facts to remember before reading other materials on functional programming are: immutability - lets you deal with complexity and helps you create code which won't surprise you WHAT not HOW - this is the question that should be answered by your code treat function as a first class citizen - your system is composed of functions - they deserve some respect. Have fun with functional programming!","tags":"","url":"Introduction\/Thinking_Functional.html"},{"title":"Fast Introduction To FP In PHP","text":"","tags":"","url":"Introduction\/Fast_Introduction_To_FP_In_PHP.html"},{"title":"Dont be afraid of monads","text":"","tags":"","url":"Introduction\/Dont_be_afraid_of_monads.html"},{"title":"PhpSlang Internal Structure","text":"","tags":"","url":"Introduction\/PhpSlang_Internal_Structure.html"},{"title":"FAQ","text":"I read a documentation and did'nt found an answer. PhpSlang treads unclear documentation as a bug. If you have any issues with understanding described concepts or something is missing or misleading - feel free to create an issue on Github Where to start with functional programming? Honestly - not with PHP. Give a chance to Scala, Haskell, or Elixir. All great ideas you'll learn out there will change the way you use PHP, but it requires a lot of discipline to write immutable, purely functional code in PHP (and PhpSlang helps you here). It can sound a little bossy but at the moment PhpSlang documentation seems to be the most comprehensive guide on functional programming in PHP. There are of course other resources and they are listed on Other resources page. When not to use functional programming? Your default approach should be - write everything functionally. I promise, when you learn to write purely functional code there is no coming back. You'll want to write everything this way and when you'll face a problem which requires different approach you'll see this. There is no specific business domain where FP or traditional OOP is better. But keep in ming that a gold hammer does'nt exist. There are two fields of a reality where there is a common belief that FP performs worse: Embedded devices - when you write code for AVR or PIC microcontrollers and every bit of a memory matters - then it's probably best to stick with a classical C development. Sorting algorithms - there's a whole story behind a quick sort implementations for a variety of functional languages and benchmarks show that because of a mutational nature of quick sort it performs worse when implementation in a purely functional way. How about things you can't implement with functional approach? If you found such problem please let us know on Gitter chat. We'll be more that happy to help you solve the problem. If you have such issue it can indicate some bugs or shortages of PhpSlang. Why some parts of PhpSlang are not purely functional? It can seem like a lack of consequence, but keep in mind a main goal of a whole project. It was created to give PHP developers tools that will enable them to benefit from functional approach in a convenient way. It hides some ugly parts of PHP. Those ugly parts are still there, but with PhpSlang you don't have to deal with them every time you want to do something. How about mixing PhpSlang with other libraries? PhpSlang does'nt change a behaviour of PHP nor adds any kind of special keywords. It just provides helpful classes and functions. It's still PHP so you can mix approaches. If you want to have consistent code style - it's good to wrap\/extend existing libraries with PhpSlang constructs eg. Option::of() for all calls returning nullable results. I use library X and it returns different results when used along with PhpSlang. There is a high chance that one of two things happened: results of computations were wrong previously, but now with FP you fixed some bugs by an accident (such magical things happen when you force yourself to formalize every aspect of an application) results of computations were correct previously, but now are wrong - it probably indicated non-thread-safe code. Some libraries highly depend on mutations (even worse on mutations of static fields or globally accessible variables). This way in a middle of computations in method A, you change a state needed by method B. Please check if switching from ParallelListCollection (or other parallel collection) to ListCollection won't solve your problem. TL;DR look for race condition. I found a bug. Place an issue on Github so we know it exists. It will be fixed ASAP. I want to use it in a commercial project Feel free - it's distributed under MIT License. When feature X will be available? See Roadmap for a reference.","tags":"","url":"Introduction\/FAQ.html"},{"title":"Copy Trait","text":"","tags":"","url":"Usage\/Essentials\/Copy_Trait.html"},{"title":"Curried Objects","text":"","tags":"","url":"Usage\/Essentials\/Curried_Objects.html"},{"title":"Option","text":"","tags":"","url":"Usage\/Essentials\/Option.html"},{"title":"Either","text":"","tags":"","url":"Usage\/Essentials\/Either.html"},{"title":"Try","text":"","tags":"","url":"Usage\/Essentials\/Try.html"},{"title":"Future","text":"","tags":"","url":"Usage\/Essentials\/Future.html"},{"title":"Pattern Matching","text":"","tags":"","url":"Usage\/Pattern_Matching.html"},{"title":"Extractors","text":"","tags":"","url":"Usage\/Extractors.html"},{"title":"Overview","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/Overview.html"},{"title":"Parallel Collections","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/Parallel_Collections.html"},{"title":"Basic Examples","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/Basic_Examples.html"},{"title":"More Examples","text":"","tags":"","url":"Usage\/Immutable_Data_Structures\/More_Examples.html"},{"title":"Operation Chaining","text":"","tags":"","url":"Usage\/Operation_Chaining.html"},{"title":"Enumeration","text":"","tags":"","url":"Usage\/Enumeration.html"},{"title":"Memoization","text":"","tags":"","url":"Usage\/Memoization.html"},{"title":"Validation And Property Testing","text":"","tags":"","url":"Usage\/Validation_And_Property_Testing.html"},{"title":"Trampolines","text":"","tags":"","url":"Usage\/Trampolines.html"},{"title":"Error Handling","text":"","tags":"","url":"Good_Practices\/Error_Handling.html"},{"title":"Dealing With Legacy Code","text":"","tags":"","url":"Good_Practices\/Dealing_With_Legacy_Code.html"},{"title":"Common Mistakes","text":"","tags":"","url":"Good_Practices\/Common_Mistakes.html"},{"title":"Top 10 Sins of PHP","text":"Top 10 sins of PHP PHP is a mature language yet it has it downsides especially in terms of functional programming (but not only). Purpouse of a following article is pointing out some problems you'll face when you'll start to code functionally (but not only). Short note: Following article compare PHP with other functional languages. Scala is given as an example but this language was picket from tons of other languages because of its popularity. Please don't take a false assumption that a basic meaning of this article is that PHP should become Scala. PHP isn't Scala and will never be and probably should'nt become one. It has it's own upsides, but this article is focused on downsides - especially in context of functional programming and gives some answers on PhpSlang purpose and history. 1. Verbose anonymous function syntax When you start to program functionally with PHP you will create new functions - a lot. And most of pure functions should contain only one return statement. Let's take a look at a following example. $users -&gt;map(function(User $user) : string { return $user-&gt;getFirstName(); }); All this simple piece of code does is transforming a list of users into a list of first names of those users. Now let's slim down this example and cut all redundant information step by step. So first - we don't need a return statement because pure functions perform only one operation or at least we could assume that a result of a last statement in a function should be returned. This is what most Scala, or even Ruby does. So this example could become: $users -&gt;map(function(User $user) : string { $user-&gt;getFirstName(); }); We also do not need a semicolons when we think about our code this way. $users -&gt;map(function(User $user) : string { $user-&gt;getFirstName() }) Third part is function keyword. We know that map() should receive a function as a 1st parameter and what we will have is still more than we need to know that this is a function definition. $users -&gt;map((User $user) : string { $user-&gt;getFirstName() }) Next part of downsizing. Take a look at curly brackets. It's quite obvious that before arguments and returned type definition there should appear actual implementation. $users -&gt;map((User $user) : string $user-&gt;getFirstName()) Just look at it. This code could all fit in a single line of code. And because we treat functions as immutable values for object we dont need brackets for functions with arity 0 (functions that take 0 arguments). $users -&gt;map((User $user) : string $user-&gt;getFirstName) We could as well remove type annotations (but it's not a good idea as long as point 2 of this list is still valid). $users -&gt;map(($user) $user-&gt;getFirstName) But all those code examples is just a fantasy. With PHP till this moment we have to stick with: $users -&gt;map(function(User $user) : string { return $user-&gt;getFirstName(); }); This is the same functionality implemented with a Scala for comparision (yes it's a working code). users .map(user =&gt; user.getFirstName) 2. No generic types This is the biggest pain in the ass of all listed PHP sins. This problem touches not only developers who want to introduce functional programming. This is a problem of a whole community and everyone who created non trivial OOP application feel this problem. On 2016-01-06 there was introduced a proposal to implement this feature. More about a proposal and shape of eventual implementation in PHP you can find at https:\/\/wiki.php.net\/rfc\/generics Fervo set a bounty for this feature: https:\/\/www.bountysource.com\/issues\/20553561-add-generics-support\/backers You can ask yourself how such feature could change my life? Well lets consider you have want to pass a list of some object to your method. function listTransformer(ListCollection $someList); OK, so we have a list. But a list of what? There is no way to define such info. You can (and should) of course try with describing content of iterables inside dockblock. \/** * @param ListCollection|User[] $someList *\/ function listTransformer(ListCollection $someList); So now we now that this parameter had to keep User entities. Some tools will handle it somehow, some not. The worst part is that such annotation has completely no impact on how our code will be executed. Dockblock annotation helps only for iterables - how about other generic methods and classes? There is no easy answer at the moment. All this mess could be resolved when we could write type definition similar to: function listTransformer(ListCollection&lt;User&gt; $someList); 3. Convenient reassignments When you decide to create purely functional code with PHP it will require a lot of discipline on your side. And there is no way to stop other team members from breaking your convention. There are no tools to prevent you from reassignments. Maybe some day PHPMD will be enriched with such functionality but such features are'nt listed in it's roadmap at the moment. Even worse - reassignments can occur even by a mistake. Take a look at following example. $pleaseIDontWantToBecomeMutant = 'regular human'; foreach ($someList as $pleaseIDontWantToBecomeMutant) { \/\/do nothing } What do you think what will be the value of a $pleaseIDontWantToBecomeMutant? Hint: definitely not a regular human. Referential non-transparency Next example. Some developer are very greedy in terms of memory (and they have their reasons). You probably used a lot of 3rd party libraries or even build-in functions taking arguments via reference. $cow = 'cow'; $chernobylFunction = function(&amp;$someArgument) { $someArgument = 'cow producing eggs'; return $someArgument; }; echo $chernobylFunction($cow); echo $cow; A sad result of this code is that $chernobylFunction will return cow producing eggs as expected, but a regular $cow will become cow producing eggs as well (and you'll see this problem on production if you don't write enough tests). And our regular cow is lost - no more milk. When you are a creator of such function you may think - I have it all under control. The problem is that users of that function don't. As a library user you have to be very careful and check every function definition if it's arguments are passed by a copy or a reference. 4. Inconvenient cloning Take a look at this class. class House { \/** * @var string *\/ private $size; public function __construct(string $size) { $this-&gt;size = $size; } public function getSize() : string { return $this-&gt;size; } public function setSize(string $newSize) : House { $this-&gt;size = $newSize; return $this; } } Nothing special isn't it? Regular class with getters and setters like we're used to have. Method setSize returns $this so we have a convenient way to chain few method for one object. Let's consider a following usage. $smallHouse = new House('small'); $bigHouse = $smallHouse-&gt;setSize('big'); echo $bigHouse-&gt;getSize(); \/\/writes 'big' echo $smallHouse-&gt;getSize(); \/\/writes 'big' as well :( What happened? We mutated a state again - somehow by an accident. OK, so you transform your code so it's purely functional. Let's say that You already read a PhpSlang documentation and you know that every function name with set as a prefix should become a similar function with with as a prefix. How to achieve it? If you used Scala such method would look somehow like: case class House(size:Int) { def withSize(newSize : Int) = copy(size = newSize) } PHP does not provide any build in features to clone objects with only selected fields changes, so you end up creating completely new objects copying all fields to constructor and changing those values you're interested in or with class which looks like this: class House { \/** * @var string *\/ public $size; public function __construct(string $size) { $this-&gt;size = $size; } public function getSize() : string { return $this-&gt;size; } public function withSize(string $newSize) : House { $clone = clone $this; $clone-&gt;size = $newSize; \/\/note that $size field had to be changed to public return $clone; } } Does'nt look very beautiful is it? PhpSlang's Copy trait partially resolves this issue and allows you to write something like: class Houser{ use Copy; \/** * @var string *\/ private $size; public function __construct(string $size) { $this-&gt;size = $size; } public function getSize() : string { return $this-&gt;size; } public function withSize(string $newSize) : House { return $this-&gt;copy('size', $newSize); } } And now you can use this class in a following way. $smallHouse = new House('small'); $bigHouse = $smallHouse-&gt;withSize('big'); echo $bigHouse-&gt;getSize(); \/\/writes 'big' echo $smallHouse-&gt;getSize(); \/\/writes 'small' as expected :) 5. Very little syntactic sugar No placeholder syntax No partially applied functions No implicit scoping No wildcard import No pipeline operator 6. Imperative ecosystem 7. Lack of Closure descriptions 8. No pattern matching 9. No macros 10. No standard for annotations","tags":"","url":"Additional_Articles\/Top_10_Sins_of_PHP.html"},{"title":"Roadmap","text":"PhpSlang is still a work in progress - please refer to this page to keep track of crucial features. 0.1.0 [x] Option monad [x] Either monad [x] Copy trait [x] Immutable List collection [x] Trampolines [x] Pattern matching 0.2.0 [x] Tuples [_] Immutable HashMap collections [_] Immutable Set collections [_] Extractors [_] Try monad 0.3.0 [_] Future monad [_] Parallel immutable List collection [_] Parallel immutable HashMap collection [_] Parallel immutable Set collection 0.4.0 [_] Validation functor [_] Property testing [_] Numeric type with infinite precision 0.5.0 [_] Lazy monad \/ Memoization [_] Chainable\\pipe monad [_] Convenient enumeration 0.6.0 [_] Doctrine integration [_] Symfony bundle","tags":"","url":"General\/Roadmap.html"},{"title":"Other Resources","text":"","tags":"","url":"General\/Other_Resources.html"},{"title":"License","text":"The MIT License (MIT) Copyright (c) 2016 Witold Adamus Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","tags":"","url":"General\/License.html"}]}